import RPi.GPIO as GPIO
import serial
import time
import threading
import smbus
import math
import csv
from rplidar import RPLidar

# ----------------- LIDAR-konfigurasjon -----------------
PORT_NAME = "/dev/ttyUSB1"  # Riktig port for LIDAR
lidar = RPLidar(PORT_NAME, baudrate=115200)

# ----------------- Serial til ESP32 -----------------
ESP_PORT = "/dev/ttyUSB0"  # Riktig port for ESP32
esp = serial.Serial(ESP_PORT, 115200, timeout=1)
time.sleep(2)  # La ESP32 starte opp

# ----------------- Kompass (HMC5883L) -----------------
I2C_BUS = 1  # Standard I2C-buss for Raspberry Pi
HMC5883L_ADDRESS = 0x0D  # Kompassmodulens adresse
bus = smbus.SMBus(I2C_BUS)

def read_compass():
    # Leser 6 byte fra kompasset og setter sammen til x, y, z
    data = bus.read_i2c_block_data(HMC5883L_ADDRESS, 0x00, 6)
    x = (data[1] << 8) | data[0]
    y = (data[3] << 8) | data[2]
    z = (data[5] << 8) | data[4]
    if x >= 0x8000:
        x -= 0x10000
    if y >= 0x8000:
        y -= 0x10000
    if z >= 0x8000:
        z -= 0x10000
    # For dette eksempelet brukes kompasset kun for � vise retningsinformasjon
    # (selve kartleggingen baseres p� LIDAR-data og robotens oppdaterte posisjon)
    heading = (180 / math.pi) * -1 * (y / x) if x != 0 else 0
    return heading

# ----------------- Globale variabler for kartlegging -----------------
# Robotens posisjon (i mm) og orientering (theta i grader)
robot_pose = {'x': 0.0, 'y': 0.0, 'theta': 0.0}
# Liste over LIDAR-punkter i globale koordinater
map_points = []
# Indikerer om roboten er i fremoverkj�ring (for � oppdatere odometri)
is_moving_forward = False

# ----------------- Parametere -----------------
STOP_DISTANCE_LIDAR = 250      # mm
STOP_DISTANCE_ULTRASOUND = 15   # (ikke brukt i dette eksempelet)
SPEED = 100                    # mm/s (antatt verdi for fremoverkj�ring)
FORWARD_DISTANCE_AFTER_TURN = 10  # mm (avstand etter rotasjon)
TIME_TO_MOVE_DIST = FORWARD_DISTANCE_AFTER_TURN / SPEED
ROTATION_SPEED = 2            # Rotasjonshastighet (enhet definert for ESP32-kommando)
ROTATION_TIME_90_DEG = 1.5    # Tid for 90� rotasjon

current_distance_lidar = 9999
running = True

# ----------------- LIDAR-tr�d med kartlegging -----------------
def lidar_thread():
    global current_distance_lidar, running, map_points, robot_pose
    for scan in lidar.iter_scans():
        # For hver LIDAR-skanning prosesserer vi alle m�linger
        for measurement in scan:
            quality, angle, distance = measurement
            # Transformer den relative vinkelen til en global vinkel
            global_angle = angle + robot_pose['theta']
            rad = math.radians(global_angle)
            # Regn ut posisjonen til m�lepunktet relativt til roboten
            x_local = distance * math.cos(rad)
            y_local = distance * math.sin(rad)
            # Konverter til global posisjon basert p� robotens posisjon
            global_x = robot_pose['x'] + x_local
            global_y = robot_pose['y'] + y_local
            map_points.append((global_x, global_y))
        
        # Ekstraher en frontavstand (innenfor �30� fra 0�) for kollisjonsdeteksjon
        front_measurements = [m[2] for m in scan if abs(m[1] - 0) <= 30]
        if front_measurements:
            current_distance_lidar = min(front_measurements)
        if not running:
            break

# ----------------- Motorstyring -----------------
def send_command(command):
    print(f"Sender til ESP32: {command.strip()}")
    esp.write(command.encode())

def rotate_by_angle(angle):
    # Beregn rotasjonstiden basert p� 90� som referanse
    rotation_time = (abs(angle) / 90) * ROTATION_TIME_90_DEG
    # Send roteringskommando; fortegnet avgj�r rotasjonsretning
    send_command(f"0 0 {ROTATION_SPEED if angle < 0 else -ROTATION_SPEED}\n")
    time.sleep(rotation_time)
    send_command("0 0 0\n")
    # Oppdater robotens orientering
    robot_pose['theta'] = (robot_pose['theta'] + angle) % 360

def move_forward():
    global is_moving_forward
    print("Kj�rer fremover")
    send_command("100 0 0\n")
    is_moving_forward = True

def stop_robot():
    global is_moving_forward
    print("Stopper roboten")
    send_command("0 0 0\n")
    is_moving_forward = False

def move_forward_distance():
    global robot_pose
    print("Kj�rer et kort stykke fremover etter rotasjon")
    send_command(f"{SPEED} 0 0\n")
    time.sleep(TIME_TO_MOVE_DIST)
    send_command("0 0 0\n")
    # Oppdater robotens posisjon basert p� bevegelsen
    distance_moved = SPEED * TIME_TO_MOVE_DIST
    rad = math.radians(robot_pose['theta'])
    robot_pose['x'] += distance_moved * math.cos(rad)
    robot_pose['y'] += distance_moved * math.sin(rad)

def save_map():
    # Lagre alle m�lte punkter til en CSV-fil
    file_path = "/home/admin/GitHub/SelfDriving/lidar_map.csv"

    with open("lidar_map.csv", "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["x", "y"])
        writer.writerows(map_points)
    print("Kartdata lagret til lidar_map.csv")

# ----------------- HOVEDPROGRAM -----------------
try:
    # Start LIDAR-tr�den for innsamling og kartlegging
    lidar_thread_obj = threading.Thread(target=lidar_thread)
    lidar_thread_obj.daemon = True
    lidar_thread_obj.start()
    
    move_forward()
    last_time = time.time()
    
    while True:
        current_time = time.time()
        dt = current_time - last_time
        last_time = current_time
        
        # Hvis roboten kj�rer fremover, oppdater odometrien (enkel integrasjon)
        if is_moving_forward:
            robot_pose['x'] += SPEED * dt * math.cos(math.radians(robot_pose['theta']))
            robot_pose['y'] += SPEED * dt * math.sin(math.radians(robot_pose['theta']))
        
        compass_heading = read_compass()
        print(f"LIDAR-avstand: {current_distance_lidar:.1f} mm | Kompassretning: {compass_heading:.2f}�")
        print(f"Robot posisjon: x = {robot_pose['x']:.1f} mm, y = {robot_pose['y']:.1f} mm, theta = {robot_pose['theta']:.1f}�")
        
        if current_distance_lidar <= STOP_DISTANCE_LIDAR:
            stop_robot()
            time.sleep(1)
            rotate_by_angle(90)
            move_forward_distance()
            move_forward()
        
        time.sleep(0.1)

except KeyboardInterrupt:
    print("Avslutter programmet...")
    running = False
    lidar.stop()
    lidar.disconnect()
    esp.close()
    GPIO.cleanup()
    save_map()
